<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Temporal disaggregation and Benchmarking methods based on JDemetra+ v3.x • rjd3bench</title>
<!-- favicons --><link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png">
<link rel="apple-touch-icon" type="image/png" sizes="180x180" href="../apple-touch-icon.png">
<link rel="apple-touch-icon" type="image/png" sizes="120x120" href="../apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" type="image/png" sizes="76x76" href="../apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" type="image/png" sizes="60x60" href="../apple-touch-icon-60x60.png">
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.4.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.4.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Temporal disaggregation and Benchmarking methods based on JDemetra+ v3.x">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">rjd3bench</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">2.1.0.9000</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="active nav-item"><a class="nav-link" href="../articles/rjd3bench.html">Get started</a></li>
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="nav-item"><a class="nav-link" href="../news/index.html">Changelog</a></li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/rjdverse/rjd3bench/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="../logo.svg" class="logo" alt=""><h1>Temporal disaggregation and Benchmarking methods based on JDemetra+ v3.x</h1>
            
      
      <small class="dont-index">Source: <a href="https://github.com/rjdverse/rjd3bench/blob/develop/vignettes/rjd3bench.Rmd" class="external-link"><code>vignettes/rjd3bench.Rmd</code></a></small>
      <div class="d-none name"><code>rjd3bench.Rmd</code></div>
    </div>

    
        <div class="abstract">
      <p class="abstract">Abstract</p>
      The package rjd3bench provides a variety of methods for temporal
      disaggregation, benchmarking, reconciliation and calendarization.
      It is part of the interface to ‘JDemetra+ 3.0’ Seasonal
      adjustement software. Methods of temporal disaggregation and
      benchmarking are used to derive high frequency time series from
      low frequency time series with or without the help of high
      frequency information. Consistency of the high frequency series
      with the low frequency series can be achieved by either the sum,
      the average, the first or last value or any other user-defined
      conversion mode. In addition to temporal constraints,
      reconciliation methods deals with contemporaneous consistency
      while adjusting multiple time series. Finally, calendarization
      method can be used when time series data do not coincide with
      calendar periods.
    </div>
    
<div class="section level2">
<h2 id="introduction">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h2>
<p>The methods implemented in the package rjd3bench intend to bridge the
gap when there is a lack of high frequency time series or when there are
temporal and/or contemporaneous inconsistencies between the high
frequency series and the corresponding low frequency series. Although
this can be an issue in any fields of research dealing with time series,
methods of temporal disaggregation, benchmarking, reconciliation and
calendarization are often encountered in the production of official
statistics. For example, National Accounts are often compiled according
to two frequencies of production: annual series, the low frequency data,
based on precise and detailed sources and quarterly series, the high
frequency data, which usually rely on less accurate sources but give
information on a timelier basis. In such case, the use of temporal
disaggregation, benchmarking, and/or reconciliation method can be used
to achieve consistency between annual and quarterly national accounts
over time.</p>
<p>The package rjd3bench is an R interface to the highly efficient
algorithms and modeling developed in the official ‘JDemetra+ 3.0’
Seasonal adjustement software. It provides a wide variety of methods,
included those suggested in the <em>ESS guidelines on temporal
disaggregation, benchmarking and reconciliation (Eurostat,
2018)</em>.</p>
</div>
<div class="section level2">
<h2 id="set-up-data">Set-up &amp; Data<a class="anchor" aria-label="anchor" href="#set-up-data"></a>
</h2>
<p>We illustrate the various methods using two datasets:</p>
<ul>
<li>The <em>retail</em> dataset contains monthly figures over retail
activity of various categories of goods and services from 1992 to
2010.</li>
<li>The <em>qna_data</em> is a list of two datasets. The first data set
‘B1G_Y_data’ includes three annual benchmark series which are the
Belgian annual value added on the period 2009-2020 in chemical industry
(CE), construction (FF) and transport services (HH). The second data set
‘TURN_Q_data’ includes the corresponding quarterly indicators which are
(modified) production indicators derived from VAT statistics and
covering the period 2009Q1-2021Q4.</li>
</ul>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="st"><a href="https://github.com/rjdverse/rjd3bench" class="external-link">"rjd3bench"</a></span><span class="op">)</span></span>
<span><span class="va">retail</span> <span class="op">&lt;-</span> <span class="fu">rjd3toolkit</span><span class="fu">::</span><span class="va"><a href="https://rjdverse.github.io/rjd3toolkit/reference/retail.html" class="external-link">retail</a></span></span>
<span><span class="va">qna_data</span> <span class="op">&lt;-</span> <span class="fu">rjd3bench</span><span class="fu">::</span><span class="va">qna_data</span></span></code></pre></div>
</div>
<div class="section level2">
<h2 id="temporal-disaggregation-methods">Temporal disaggregation methods<a class="anchor" aria-label="anchor" href="#temporal-disaggregation-methods"></a>
</h2>
<div class="section level3">
<h3 id="chow-lin-fernandez-and-litterman">Chow-Lin, Fernandez and Litterman<a class="anchor" aria-label="anchor" href="#chow-lin-fernandez-and-litterman"></a>
</h3>
<p>Eurostat (2018) recommends the use of regression-based models for the
purpose of temporal disaggregation. Among them, we retrieve the Chow-Lin
method and its variants Fernandez and Litterman.</p>
<p>Let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Y</mi><mi>T</mi></msub><annotation encoding="application/x-tex">Y_T</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">T=1,...,m</annotation></semantics></math>,
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>x</mi><mi>t</mi></msub><annotation encoding="application/x-tex">x_t</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">t=1,...,n</annotation></semantics></math>,
be, respectively the observed low frequency benchmark and the
high-frequency indicator of an unknown high frequency variable
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>y</mi><mi>t</mi></msub><annotation encoding="application/x-tex">y_t</annotation></semantics></math>.
Chow-Lin, Fernandez and Litterman can be all expressed with the same
equation, but with different models for the error term:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mi>t</mi></msub><mo>=</mo><msub><mi>x</mi><mi>t</mi></msub><mi>β</mi><mo>+</mo><msub><mi>u</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">
y_t = x_t\beta+u_t
</annotation></semantics></math> where</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>u</mi><mi>t</mi></msub><mo>=</mo><mi>ϕ</mi><msub><mi>u</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>ϵ</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">u_t = \phi u_{t-1} + \epsilon_t</annotation></semantics></math>,
with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">|</mo><mi>ϕ</mi><mo stretchy="true" form="postfix">|</mo></mrow><mo>&lt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">|\phi| &lt; 1</annotation></semantics></math>
(Chow-Lin),</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>u</mi><mi>t</mi></msub><mo>=</mo><msub><mi>u</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>ϵ</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">u_t = u_{t-1} + \epsilon_t</annotation></semantics></math>
(Fernandez),</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>u</mi><mi>t</mi></msub><mo>=</mo><msub><mi>u</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><mi>ϕ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>Δ</mi><msub><mi>u</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><msub><mi>ϵ</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">u_t = u_{t-1} + \phi(\Delta u_{t-1}) + \epsilon_t</annotation></semantics></math>,
with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">|</mo><mi>ϕ</mi><mo stretchy="true" form="postfix">|</mo></mrow><mo>&lt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">|\phi| &lt; 1</annotation></semantics></math>
(Litterman)</p>
<p>While
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>x</mi><mi>t</mi></msub><annotation encoding="application/x-tex">x_t</annotation></semantics></math>
is observed in high frequency,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>y</mi><mi>t</mi></msub><annotation encoding="application/x-tex">y_t</annotation></semantics></math>
is only observed in low frequency, and therefore the number of effective
observations to estimate the parameters are the number of observations
in the low-frequency benchmark.</p>
<p>Regression-based methods can be called with the
<code><a href="../reference/temporaldisaggregation.html">temporaldisaggregation()</a></code> function.</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Example: Use of Fernandez variant to disaggregate annual value added in construction sector using a quarterly indicator</span></span>
<span><span class="va">Y</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/ts.html" class="external-link">ts</a></span><span class="op">(</span><span class="va">qna_data</span><span class="op">$</span><span class="va">B1G_Y_data</span><span class="op">[</span>, <span class="st">"B1G_FF"</span><span class="op">]</span>, frequency<span class="op">=</span><span class="fl">1</span>, start<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">2009</span>, <span class="fl">1</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">x</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/ts.html" class="external-link">ts</a></span><span class="op">(</span><span class="va">qna_data</span><span class="op">$</span><span class="va">TURN_Q_data</span><span class="op">[</span>, <span class="st">"TURN_INDEX_FF"</span><span class="op">]</span>, frequency<span class="op">=</span><span class="fl">4</span>, start<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">2009</span>, <span class="fl">1</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">td_fern</span> <span class="op">&lt;-</span> <span class="fu">rjd3bench</span><span class="fu">::</span><span class="fu"><a href="../reference/temporaldisaggregation.html">temporaldisaggregation</a></span><span class="op">(</span><span class="va">Y</span>, indicators<span class="op">=</span><span class="va">x</span>, model <span class="op">=</span> <span class="st">"Rw"</span><span class="op">)</span></span>
<span></span>
<span><span class="va">y_fern</span> <span class="op">&lt;-</span> <span class="va">td_fern</span><span class="op">$</span><span class="va">estimation</span><span class="op">$</span><span class="va">disagg</span> <span class="co"># the disaggregated series</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">td_fern</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">td_fern</span><span class="op">)</span></span></code></pre></div>
<p>The output of the <code><a href="../reference/temporaldisaggregation.html">temporaldisaggregation()</a></code> function
contains the most important information about the regression including
the estimates of model coefficients and their covariance matrix, the
decomposition of the disaggregated series and information about the
residuals. The print(), summary() and plot() functions can also be
applied on the output object. The plot() function displays the
decomposition of the disaggregated series between regression and
smoothing effect.</p>
</div>
<div class="section level3">
<h3 id="model-based-denton">Model-based Denton<a class="anchor" aria-label="anchor" href="#model-based-denton"></a>
</h3>
<p>Denton method and variants are usually expressed in mathematical
terms as a constrained minimization problem. For example, the widely
used Denton proportional first difference (PFD) method is usually
expressed as follows:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>i</mi><msub><mi>n</mi><msub><mi>y</mi><mi>t</mi></msub></msub><munderover><mo>∑</mo><mrow><mi>t</mi><mo>=</mo><mn>2</mn></mrow><mi>n</mi></munderover><mo minsize="2.4" maxsize="2.4" stretchy="false" form="prefix">[</mo><mfrac><msub><mi>y</mi><mi>t</mi></msub><msub><mi>x</mi><mi>t</mi></msub></mfrac><mo>−</mo><mfrac><msub><mi>y</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><msub><mi>x</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub></mfrac><msup><mo minsize="2.4" maxsize="2.4" stretchy="false" form="postfix">]</mo><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">
min_{y_t}\sum^n_{t=2}\biggl[\frac{y_t}{x_t}-\frac{y_{t-1}}{x_{t-1}}\biggr]^2
</annotation></semantics></math> subject to the temporal constraint
(flow variables)
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><munder><mo>∑</mo><mi>t</mi></munder><msub><mi>y</mi><mi>t</mi></msub><mo>=</mo><msub><mi>Y</mi><mi>T</mi></msub></mrow><annotation encoding="application/x-tex">
\sum_{t} y_t = Y_T
</annotation></semantics></math> where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>y</mi><mi>t</mi></msub><annotation encoding="application/x-tex">y_t</annotation></semantics></math>
is the value of the estimate of the high frequency series at period t,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>x</mi><mi>t</mi></msub><annotation encoding="application/x-tex">x_t</annotation></semantics></math>
is the value of the high frequency indicator at period t and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Y</mi><mi>T</mi></msub><annotation encoding="application/x-tex">Y_T</annotation></semantics></math>
is the value of the low frequency series (i.e. the benchmark series) at
period T.</p>
<p>Equivalently, the Denton PFD method can also be expressed as a
statistical model considering the following state space
representation</p>
<p><span class="math display">$$
\begin{aligned}
y_t &amp;= \beta_t x_t \\
\beta_{t+1} &amp;= \beta_t + \varepsilon_t \qquad \varepsilon_t \sim
{\sf NID}(0, \sigma^2_{\varepsilon})
\end{aligned}
$$</span></p>
<p>where the temporal constraints are taken care of by considering a
cumulated series
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>y</mi><mi>t</mi><mi>c</mi></msubsup><annotation encoding="application/x-tex">y^c_t</annotation></semantics></math>
instead of the original series
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>y</mi><mi>t</mi></msub><annotation encoding="application/x-tex">y_t</annotation></semantics></math>.
Hence, the last high frequency period (for example, the last quarter of
the year) is observed and corresponds to the value of the benchmark. The
value of the other periods are initially defined as missing and
estimated by maximum likelihood.</p>
<p>This alternative representation of Denton PFD method is interesting
as it allows more flexibility. We might now include outliers - namely,
level shift(s) in the Benchmark to Indicator ratio - that could
otherwise induce undesirable wave effects. Outliers and their intensity
are defined by changing the value of the innovation variances. There is
also the possibility to freeze the disaggregated series at some specific
period(s) or prior a certain date by fixing the high-frequency BI
ratio(s). Following the principle of movement preservation inherent to
Denton, the model-based Denton PFD method constitutes an interesting
alternative for both temporal disaggregation and benchmarking. Here is a
<a href="https://www.youtube.com/watch?v=PC0tj2jMcuU" class="external-link">link</a> to a
presentation on the subject which include some comparison with the
regression-based methods for temporal disaggregation.</p>
<p>The model-base Denton method can be applied with the
<code><a href="../reference/denton_modelbased.html">denton_modelbased()</a></code> function.</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Example: Use of model-based Denton for temporal disaggregation</span></span>
<span><span class="va">Y</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/ts.html" class="external-link">ts</a></span><span class="op">(</span><span class="va">qna_data</span><span class="op">$</span><span class="va">B1G_Y_data</span><span class="op">[</span>, <span class="st">"B1G_FF"</span><span class="op">]</span>, frequency<span class="op">=</span><span class="fl">1</span>, start<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">2009</span>, <span class="fl">1</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">x</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/ts.html" class="external-link">ts</a></span><span class="op">(</span><span class="va">qna_data</span><span class="op">$</span><span class="va">TURN_Q_data</span><span class="op">[</span>, <span class="st">"TURN_INDEX_FF"</span><span class="op">]</span>, frequency<span class="op">=</span><span class="fl">4</span>, start<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">2009</span>, <span class="fl">1</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">td_mbd</span> <span class="op">&lt;-</span> <span class="fu">rjd3bench</span><span class="fu">::</span><span class="fu"><a href="../reference/denton_modelbased.html">denton_modelbased</a></span><span class="op">(</span><span class="va">Y</span>, <span class="va">x</span>, outliers <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="st">"2020-01-01"</span><span class="op">=</span><span class="fl">100</span>, <span class="st">"2020-04-01"</span><span class="op">=</span><span class="fl">100</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="va">y_mbd</span> <span class="op">&lt;-</span> <span class="va">td_mbd</span><span class="op">$</span><span class="va">estimation</span><span class="op">$</span><span class="va">disagg</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">td_mbd</span><span class="op">)</span></span></code></pre></div>
<p>The output of the <code><a href="../reference/denton_modelbased.html">denton_modelbased()</a></code> function contains
information about the disaggregated series and the BI ratio as well as
their respecting errors making it possible to construct confidence
intervals. The print(), summary() and plot() functions can also be
applied on the output object.The plot() function displays the
disaggregated series and the BI ratio together with their respective 95%
confidence interval.</p>
</div>
<div class="section level3">
<h3 id="autoregressive-distributed-lag-adl-models">Autoregressive Distributed Lag (ADL) Models<a class="anchor" aria-label="anchor" href="#autoregressive-distributed-lag-adl-models"></a>
</h3>
<p>(Upcoming content)</p>
</div>
</div>
<div class="section level2">
<h2 id="benchmarking-methods">Benchmarking methods<a class="anchor" aria-label="anchor" href="#benchmarking-methods"></a>
</h2>
<div class="section level3">
<h3 id="denton">Denton<a class="anchor" aria-label="anchor" href="#denton"></a>
</h3>
<p>Denton methods relies on the principle of movement preservation.
There exist several variants corresponding to different definitions of
movement preservation: additive first difference (AFD), proportional
first difference (PFD), additive second difference (ASD), proportional
second difference (PSD).</p>
<p>The most widely used is the Denton PFD variant. Let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Y</mi><mi>T</mi></msub><annotation encoding="application/x-tex">Y_T</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">T=1,...,m</annotation></semantics></math>,
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>x</mi><mi>t</mi></msub><annotation encoding="application/x-tex">x_t</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">t=1,...,n</annotation></semantics></math>,
be, respectively the temporal benchmarks and the high-frequency
preliminary values of an unknown target variable
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>y</mi><mi>t</mi></msub><annotation encoding="application/x-tex">y_t</annotation></semantics></math>.
The objective function of the Denton PFD method is as follows
(considering the small modification suggested by Cholette to deal with
the starting conditions of the problem):
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>i</mi><msub><mi>n</mi><msub><mi>y</mi><mi>t</mi></msub></msub><munderover><mo>∑</mo><mrow><mi>t</mi><mo>=</mo><mn>2</mn></mrow><mi>n</mi></munderover><mo minsize="2.4" maxsize="2.4" stretchy="false" form="prefix">[</mo><mfrac><msub><mi>y</mi><mi>t</mi></msub><msub><mi>x</mi><mi>t</mi></msub></mfrac><mo>−</mo><mfrac><msub><mi>y</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><msub><mi>x</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub></mfrac><msup><mo minsize="2.4" maxsize="2.4" stretchy="false" form="postfix">]</mo><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">
min_{y_t}\sum^n_{t=2}\biggl[\frac{y_t}{x_t}-\frac{y_{t-1}}{x_{t-1}}\biggr]^2
</annotation></semantics></math> This objective function is minimized
subject to the temporal aggregation constraints
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>∑</mo><mrow><mi>t</mi><mi>ϵ</mi><mi>T</mi></mrow></msub><mo>=</mo><msub><mi>Y</mi><mi>T</mi></msub></mrow><annotation encoding="application/x-tex">\sum_{t\epsilon T}=Y_T</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">T=1,...,m</annotation></semantics></math>
(flows variables). In other words, the benchmarked series is estimated
in such a way that the “Benchmark-to-Indicator” ratio
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><msub><mi>y</mi><mi>t</mi></msub><msub><mi>x</mi><mi>t</mi></msub></mfrac><annotation encoding="application/x-tex">\frac{y_t}{x_t}</annotation></semantics></math>
remains as smooth as possible, which is often of key interest in
benchmarking.</p>
<p>In the literature (see for example Di Fonzo and Marini, 2011), Denton
PFD is generally considered as a good approximation of the <a href="#grp">GRP method</a>, meaning that it preserves the
period-to-period growth rates of the preliminary series. It is also
argued that in many applications, Denton PFD is more appropriate than
GRP method as it deals with a linear problem which is computationally
easier, and does not suffer from the issues related to time
irreversibility and singular objective function when
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>y</mi><mi>t</mi></msub><annotation encoding="application/x-tex">y_t</annotation></semantics></math>
approaches 0 (see Daalmans et al, 2018).</p>
<p>Denton methods can be called with the <code><a href="../reference/denton.html">denton()</a></code>
function.</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Example: use Denton method for benchmarking</span></span>
<span><span class="va">Y</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/ts.html" class="external-link">ts</a></span><span class="op">(</span><span class="va">qna_data</span><span class="op">$</span><span class="va">B1G_Y_data</span><span class="op">[</span>, <span class="st">"B1G_HH"</span><span class="op">]</span>, frequency<span class="op">=</span><span class="fl">1</span>, start<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">2009</span>, <span class="fl">1</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="va">y_den0</span> <span class="op">&lt;-</span> <span class="fu">rjd3bench</span><span class="fu">::</span><span class="fu"><a href="../reference/denton.html">denton</a></span><span class="op">(</span>t<span class="op">=</span><span class="va">Y</span>, nfreq<span class="op">=</span><span class="fl">4</span><span class="op">)</span> <span class="co"># denton PFD without high frequency series</span></span>
<span></span>
<span><span class="va">x</span> <span class="op">&lt;-</span> <span class="va">y_den0</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">rnorm</a></span><span class="op">(</span>n<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">y_den0</span><span class="op">)</span>, mean<span class="op">=</span><span class="fl">0</span>, sd<span class="op">=</span><span class="fl">10</span><span class="op">)</span></span>
<span><span class="va">y_den1</span> <span class="op">&lt;-</span> <span class="fu">rjd3bench</span><span class="fu">::</span><span class="fu"><a href="../reference/denton.html">denton</a></span><span class="op">(</span>s<span class="op">=</span><span class="va">x</span>, t<span class="op">=</span><span class="va">Y</span><span class="op">)</span> <span class="co"># denton PFD (= the default)</span></span>
<span><span class="va">y_den2</span> <span class="op">&lt;-</span> <span class="fu">rjd3bench</span><span class="fu">::</span><span class="fu"><a href="../reference/denton.html">denton</a></span><span class="op">(</span>s<span class="op">=</span><span class="va">x</span>, t<span class="op">=</span><span class="va">Y</span>, d<span class="op">=</span><span class="fl">2</span>, mul<span class="op">=</span><span class="cn">FALSE</span><span class="op">)</span> <span class="co"># denton ASD</span></span></code></pre></div>
<p>The <code><a href="../reference/denton.html">denton()</a></code> function returns the benchmarked high
frequency series.</p>
</div>
<div class="section level3">
<h3 id="grp">Growth rate preservation (GRP)<a class="anchor" aria-label="anchor" href="#grp"></a>
</h3>
<p>GRP explicitly preserves the period-to-period growth rates of the
preliminary series.</p>
<p>Let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Y</mi><mi>T</mi></msub><annotation encoding="application/x-tex">Y_T</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">T=1,...,m</annotation></semantics></math>,
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>x</mi><mi>t</mi></msub><annotation encoding="application/x-tex">x_t</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">t=1,...,n</annotation></semantics></math>,
be, respectively the temporal benchmarks and the high-frequency
preliminary values of an unknown target variable
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>y</mi><mi>t</mi></msub><annotation encoding="application/x-tex">y_t</annotation></semantics></math>.
Cauley and Trager(1981) consider the following objective function:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><munderover><mo>∑</mo><mrow><mi>t</mi><mo>=</mo><mn>2</mn></mrow><mi>n</mi></munderover><msup><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><msub><mi>y</mi><mi>t</mi></msub><msub><mi>y</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub></mfrac><mo>−</mo><mfrac><msub><mi>x</mi><mi>t</mi></msub><msub><mi>x</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">
f(x) = \sum_{t=2}^{n}\left(\frac{y_t}{y_{t-1}} - \frac{x_t}{x_{t-1}}\right)^2
</annotation></semantics></math> and look for values
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>y</mi><mi>t</mi><mo>*</mo></msubsup><annotation encoding="application/x-tex">y_t^*</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">t=1,...,n</annotation></semantics></math>,
which minimize it subject to the temporal aggregation constraints
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>∑</mo><mrow><mi>t</mi><mi>ϵ</mi><mi>T</mi></mrow></msub><mo>=</mo><msub><mi>Y</mi><mi>T</mi></msub></mrow><annotation encoding="application/x-tex">\sum_{t\epsilon T}=Y_T</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">T=1,...,m</annotation></semantics></math>
(flows variables). In other words, the benchmarked series is estimated
in such a way that its temporal dynamics; as expressed by the growth
rates
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><msubsup><mi>y</mi><mi>t</mi><mo>*</mo></msubsup><msubsup><mi>y</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow><mo>*</mo></msubsup></mfrac><annotation encoding="application/x-tex">\frac{y_t^*}{y_{t-1}^*}</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo><mn>2</mn><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">t=2,...,n</annotation></semantics></math>,
be “as close as possible” to the temporal dynamics of the preliminary
series, where the “distance” from the preliminary growth rates
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><msub><mi>x</mi><mi>t</mi></msub><msub><mi>x</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub></mfrac><annotation encoding="application/x-tex">\frac{x_t}{x_{t-1}}</annotation></semantics></math>
is given by the sum of the squared differences. (Di Fonzo, Marini,
2011)</p>
<p>The objective function considered by Cauley and Trager is a natural
measure of the movement of a time series and as one would expect, it is
usually slightly better than the Denton PFD method at preserving the
movement of the series (Di Fonzo, Marini, 2011). However, unlike the
Denton PFD method which deals with a linear problem, GRP solves a more
difficult nonlinear problem. Furthermore, the GRP method suffers from a
couple of drawbacks, which are time irreversibility and potential
singularities in the objective function when
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>y</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><annotation encoding="application/x-tex">y_{t-1}</annotation></semantics></math>
approaches to 0, which could lead to undesirable results (see Daalmans
et al, 2018).</p>
<p>The GRP method, corresponding to the method of Cauley and Trager,
using the solution proposed by Di Fonzo and Marini (2011), can be called
with the <code><a href="../reference/grp.html">grp()</a></code> function.</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Example: use GRP method for benchmarking</span></span>
<span><span class="va">Y</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/ts.html" class="external-link">ts</a></span><span class="op">(</span><span class="va">qna_data</span><span class="op">$</span><span class="va">B1G_Y_data</span><span class="op">[</span>, <span class="st">"B1G_HH"</span><span class="op">]</span>, frequency<span class="op">=</span><span class="fl">1</span>, start<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">2009</span>, <span class="fl">1</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">y_den0</span> <span class="op">&lt;-</span> <span class="fu">rjd3bench</span><span class="fu">::</span><span class="fu"><a href="../reference/denton.html">denton</a></span><span class="op">(</span>t<span class="op">=</span><span class="va">Y</span>, nfreq<span class="op">=</span><span class="fl">4</span><span class="op">)</span></span>
<span><span class="va">x</span> <span class="op">&lt;-</span> <span class="va">y_den0</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">rnorm</a></span><span class="op">(</span>n<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">y_den0</span><span class="op">)</span>, mean<span class="op">=</span><span class="fl">0</span>, sd<span class="op">=</span><span class="fl">10</span><span class="op">)</span></span>
<span></span>
<span><span class="va">y_grp</span> <span class="op">&lt;-</span> <span class="fu">rjd3bench</span><span class="fu">::</span><span class="fu"><a href="../reference/grp.html">grp</a></span><span class="op">(</span>s<span class="op">=</span><span class="va">x</span>, t<span class="op">=</span><span class="va">Y</span><span class="op">)</span></span></code></pre></div>
<p>The <code><a href="../reference/grp.html">grp()</a></code> function returns the high frequency series
benchmarked with the GRP method.</p>
</div>
<div class="section level3">
<h3 id="cubic-splines">Cubic splines<a class="anchor" aria-label="anchor" href="#cubic-splines"></a>
</h3>
<p>Cubic splines are piecewise cubic functions that are linked together
in a way to guarantee smoothness at data points. Additivity constraints
are added for benchmarking purpose and sub-period estimates are derived
from each spline. When a sub-period indicator (or disaggregated series)
is used, cubic splines are no longer drawn based on the low frequency
data but the Benchmark-to-Indicator (BI ratio) is the one being
smoothed. Sub-period estimates are then simply the product between the
smoothed high frequency BI ratio and the indicator.</p>
<p>The method can be called through the <code><a href="../reference/cubicspline.html">cubicspline()</a></code>
function. Here are a few examples on how to use it:</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">y_cs1</span><span class="op">&lt;-</span><span class="fu">rjd3bench</span><span class="fu">::</span><span class="fu"><a href="../reference/cubicspline.html">cubicspline</a></span><span class="op">(</span>t<span class="op">=</span><span class="va">Y</span>, nfreq<span class="op">=</span><span class="fl">4</span><span class="op">)</span> <span class="co"># example of cubic spline without high frequency series (smoothing)</span></span>
<span></span>
<span><span class="va">x</span><span class="op">&lt;-</span><span class="va">y_cs1</span><span class="op">+</span><span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">rnorm</a></span><span class="op">(</span>n<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">y_cs1</span><span class="op">)</span>, mean<span class="op">=</span><span class="fl">0</span>, sd<span class="op">=</span><span class="fl">10</span><span class="op">)</span></span>
<span><span class="va">y_cs2</span><span class="op">&lt;-</span><span class="fu">rjd3bench</span><span class="fu">::</span><span class="fu"><a href="../reference/cubicspline.html">cubicspline</a></span><span class="op">(</span>s<span class="op">=</span><span class="va">x</span>, t<span class="op">=</span><span class="va">Y</span><span class="op">)</span> <span class="co"># example of cubic spline with a high frequency series to benchmark</span></span></code></pre></div>
<p>The <code><a href="../reference/cubicspline.html">cubicspline()</a></code> function returns the high frequency
series benchmarked with cubic spline method.</p>
</div>
<div class="section level3">
<h3 id="cholette-method">Cholette method<a class="anchor" aria-label="anchor" href="#cholette-method"></a>
</h3>
<p>(Upcoming content)</p>
</div>
</div>
<div class="section level2">
<h2 id="reconciliation-and-multivariate-temporal-disaggregation">Reconciliation and multivariate temporal disaggregation<a class="anchor" aria-label="anchor" href="#reconciliation-and-multivariate-temporal-disaggregation"></a>
</h2>
<div class="section level3">
<h3 id="multivariate-cholette">Multivariate Cholette<a class="anchor" aria-label="anchor" href="#multivariate-cholette"></a>
</h3>
<p>(Upcoming content)</p>
</div>
</div>
<div class="section level2">
<h2 id="calendarization">Calendarization<a class="anchor" aria-label="anchor" href="#calendarization"></a>
</h2>
<p>(Upcoming content)</p>
</div>
<div class="section level2">
<h2 id="references">References<a class="anchor" aria-label="anchor" href="#references"></a>
</h2>
<p>Causey, B., and Trager, M.L. (1981). Derivation of Solution to the
Benchmarking Problem: Trend Revision. Unpublished research notes, U.S.
Census Bureau, Washington D.C. Available as an appendix in Bozik and
Otto (1988).</p>
<p>Chamberlin, G. (2010). Temporal disaggregation. <em>ONS Economic
&amp; Labour Market Review</em>.</p>
<p>Di Fonzo, T., and Marini, M. (2011). A Newton’s Method for
Benchmarking Time Series according to a Growth Rates Preservation
Principle. <em>IMF WP/11/179</em>.</p>
<p>Daalmans, J., Di Fonzo, T., Mushkudiani, N., Bikker, R. (2018).
Growth Rates Preservation (GRP) temporal benchmarking: Drawbacks and
alternative solutions. <em>Survey Methodology, June 2018 Vol.44, No.1,
pp. 43-60 Statistics Canada, Catalogue No. 12-001-X</em>.</p>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by Jean Palate, Corentin Lemasson.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.1.</p>
</div>

    </footer>
</div>





  </body>
</html>
